阻塞式队列在插入和删除操作时，如果队列已满或为空，操作不会被立即执行，而是将调用这个操作的线程阻塞队列直到操作可以执行成功

BlockingQueue接口
该接口提供了几个操作元素的方法
添加元素：add、put、offer，获取元素:take、poll。他们的区别如下：
* add：添加元素。和collection的add一样，如果当前没有可用的空间，则抛出 IllegalStateException异常
* put: 添加元素。如果没有可用的空间，将阻塞，直到能够有空间插入元素
* offer:添加元素。成功时返回 true，如果当前没有可用的空间，则返回 false，不会抛异常，可以设置等待时间
* take:获取并移除此队列的头部。没有元素时，一直阻塞等待。
* poll：获取并移除此队列的头部。可以设置等待时间。

BlockingQueue最经典的使用就是用于生产者-消费者设计的实现，不需要自己通过wait-notify来控制了。

BlockingQueue的子接口
* BlockingDeque：双端阻塞队列，相对于BlockingQueue支持两个额外的操作：获取元素时等待双端队列变为非空；存储元素时等待双端队列中的空间变得可用。 


BlockingQueue的实现类
* ArrayBlockingQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。
* LinkedBlockingQueue：一个基于链接节点的有界队列。此队列按 FIFO（先进先出）排序元素。
* PriorityBlockingQueue：一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。
* DelayQueue：一个无界阻塞队列，只有在延迟期满时才能从中提取元素。
* SynchronousQueue：一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。
* DelayedWorkQueue：他是ScheduledThreadPoolExecutor的静态内部类
* TransferQueue: jdk1.7新增的接口。转移队列接口，生产者要等消费者消费的队列，生产者尝试把元素直接转移给消费者
* LinkedTransferQueue：它是TransferQueue接口的实现类。转移队列的链表实现，它比SynchronousQueue更快

BlockingDeque的实现类
* LinkedBlockingDeque：一个基于链接节点的阻塞双端队列



SynChronousQueue
其中每个插入操作必须等待另一个线程的对应移除操作，否则一直阻塞。该队列没有存储能力，不会缓存数据。

下面通过一个例子来理解它的用途。以生产者-消费者来演示，这里我有两个生产这，没有不消费者（代码已注释）。
```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.SynchronousQueue;

public class Test {

	private static SynchronousQueue<String> queue = new SynchronousQueue<String>();  

	public static void main(String[] args) {
		new Productor(1).start();
		new Productor(2).start();
		//new Consumer().start();
		//new Consumer().start();
		System.out.println("main thread is completed!");
	}

	// 生产者
	static class Productor extends Thread {
		private int id;

		public Productor(int id) {
			this.id = id;
		}

		@Override
		public void run() {
			try {
				String result = "productor id=" + this.id;
				System.out.println("produce begin... " + result);
				queue.put(result);
				System.out.println("produce success " + result);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	// 消费者
	static class Consumer extends Thread {
		@Override
		public void run() {
			try {
				System.out.println("consume begin... ");
				String v = queue.take();
				System.out.println("consume success " + v);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

}
```
控制台打印
```plain
produce begin... productor id=1
produce begin... productor id=2
main thread is completed!

```
两个生产者都卡在了queue.put(result);程序挂住了。

现在打开一个消费者，再运行，结果如下
```plain
produce begin... productor id=1
produce begin... productor id=2
main thread is completed!
consume begin... 
produce success productor id=2
consume success productor id=2

```
有一个生产者卡住了，同时程序也挂住了。

再打开两个消费者
```plain
produce begin... productor id=1
produce begin... productor id=2
consume begin... 
main thread is completed!
consume success productor id=2
consume begin... 
produce success productor id=2
produce success productor id=1
consume success productor id=1

```
程序正常停止。

我们通过例子已经明显的看到了使用SynChronousQueue达到的效果。

SynchronousQueue和长度为1的BlockingQueue的区别
我们将例子中，注释掉消费者，将queue参数改成
```java
private static ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<String>(1);
```
其他不变，结果如下
```plain
produce begin... productor id=1
produce begin... productor id=2
main thread is completed!
produce success productor id=1

```
第一个生产者生产成功，由于容量是1，所以第二个生产者将等待。
我们可以看出他们的区别：没有消费者的情况下，长度为1的阻塞队列可以让生产者生产1个商品并存储在阻塞队列中；而同步队列不允许生产者进行生产。

SynchronousQueue的使用场景
参考stackoverflow[这个问题](https://stackoverflow.com/questions/4954708/single-threading-a-task-without-queuing-further-requests)提的需求:
> I have a requirement for a task to be executed asynchronously while discarding any further requests until the task is finished.

最容易想到的方法是用newSingleThreadExecutor结合信号量Semaphore实现
```java
package com.gotoback.current;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class ThreadPoolTester {
	private static ExecutorService executor = Executors.newSingleThreadExecutor();
	private static Semaphore processEntry = new Semaphore(1);

	public static void main(String[] args) throws InterruptedException {
		for (int i = 0; i < 20; i++) {
			kickOffEntry(i);

			Thread.sleep(200);
		}

		executor.shutdown();
	}

	private static void kickOffEntry(final int index) {
		if (!processEntry.tryAcquire())
			return;
		executor.submit(new Callable<Void>() {
			public Void call() throws InterruptedException {
				try {
					System.out.println("start " + index);
					Thread.sleep(1000); // pretend to do work
					System.out.println("stop " + index);
					return null;

				} finally {
					processEntry.release();
				}
			}
		});
	}
}
```
控制台打印
```plain
start 0
stop 0
start 6
stop 6
start 11
stop 11
start 17
stop 17

```
改用SynchronousQueue实现
```java
package com.gotoback.current;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class SyncQueueTester2 {
	private static ExecutorService executor = new ThreadPoolExecutor(1, 1, 1000, TimeUnit.SECONDS,
			new SynchronousQueue<Runnable>(), new ThreadPoolExecutor.DiscardPolicy());

	public static void main(String[] args) throws InterruptedException {
		for (int i = 0; i < 20; i++) {
			kickOffEntry(i);

			Thread.sleep(200);
		}

		executor.shutdown();
	}

	private static void kickOffEntry(final int index) {
		executor.submit(new Callable<Void>() {
			public Void call() throws InterruptedException {
				System.out.println("start " + index);
				Thread.sleep(1000); // pretend to do work
				System.out.println("stop " + index);
				return null;
			}
		});
	}
}
```

