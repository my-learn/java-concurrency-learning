ConcurrentMap接口
并发Map的接口，定义了putIfAbsent(k,v)、remove(k,v)、replace(k,oldV,newV)、replace(k,v)这四个并发场景下特定的方法

实现类
* ConcurrentHashMap：ConcurrentHashMap是线程安全的HashMap的实现
* ConcurrentNavigableMap：NavigableMap的实现类，返回最接近的一个元素
* ConcurrentSkipListMap：它也是NavigableMap的实现类（要求元素之间可以比较），同时它比ConcurrentHashMap更加scalable。ConcurrentHashMap并不保证它的操作时间，并且你可以自己来调整它的load factor；但是ConcurrentSkipListMap可以保证O(log n)的性能，同时不能自己来调整它的并发参数，只有你确实需要快速的遍历操作，并且可以承受额外的插入开销的时候，才去使用它



# ConcurrentHashMap
##　介绍
Map结构的类（key-value），最早是HashTable，所有方法都是同步的，但是每次操作都是通过synchronized锁住整张表让线程独占，性能非常低。
后来有了HashMap，为了提高了性能，去掉同步，所以它是非线程安全的。
当然还有一个工具类Collections.synchronizedMap(Map<K,V> m) ，原理也是用synchronized实现的。

如何能做到既保证了线程安全，又做到高性能呢？
那么，在JDK1.5的并发包中，新增了ConcurrentHashMap这个线程安全的Map，他兼顾了线程安全和性能。

## 使用
它的使用同HashMap的API是一样的，因为它也是Map的子类
```java
Map<String,String> map = new ConcurrentHashMap<String,String>();
```
看似简单的使用，背后却是精巧的设计和复杂的实现，让我们来一探究竟。

##一探究竟
因为HashMap是非线程安全的，就没必要讨论了，这里主要比较一下ConcurrentHashMap相对于HashTable做了哪些努力和改进
ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度以及如何锁。如图




