# Thread类中的常用方法

1）start方法
该方法用来启动一个线程


2）run方法
继承Thread的类，必须要重写run方法，在run方法中定义具体要执行的任务

3）sleep方法
sleep方法有两个重载版本：
```java 
sleep(long millis)     //参数为毫秒
 
sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒
```
sleep方法不会释放锁
如果休眠中线程被中断，该方法就会立即抛出InterruptedException异常，而不需要等待到线程休眠时间结束

4）yield方法
调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。通常来说，yield()方法只做调试使用。
** 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。**

5）join方法
当一个线程对象的join()方法被调用时，调用它的线程将被挂起，直到这个线程对象完成它的任务。
join方法有三个重载版本，时间参数作用是：当前线程挂起直到调用线程执行完毕或达到join(long millis) 方法设定的时间。
```java
join()
join(long millis)     //参数为毫秒
join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒
```
假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。
下面是一个简单是使用示例
```java
public static void main(String[] args) throws IOException  {
	System.out.println("进入线程"+Thread.currentThread().getName());
	Test test = new Test();
	MyThread thread1 = test.new MyThread();
	thread1.start();
	try {
		System.out.println("线程"+Thread.currentThread().getName()+"等待");
		thread1.join();
		System.out.println("线程"+Thread.currentThread().getName()+"继续执行");
	} catch (InterruptedException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
} 
```
在该例子中，当调用thread1.join()方法后，main线程会进入等待，然后等待thread1执行完之后再继续执行。
** 其实查看源码可以知道，join方法是调用了Object的wait方法的 **

6）interrupt方法
中断线程。单独调用interrupt方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程，使其抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。
下面看一个例子:
```java
public class Test {
     
    public static void main(String[] args) throws IOException  {
        Test test = new Test();
        MyThread thread = test.new MyThread();
        thread.start();
        try {
            Thread.currentThread().sleep(2000);
        } catch (InterruptedException e) {
             
        }
        thread.interrupt();
    } 
     
    class MyThread extends Thread{
        @Override
        public void run() {
            try {
                System.out.println("进入睡眠状态");
                Thread.currentThread().sleep(10000);
                System.out.println("睡眠完毕");
            } catch (InterruptedException e) {
                System.out.println("得到中断异常");
            }
            System.out.println("run方法执行完毕");
        }
    }
}
```
输出结果：
```
进入睡眠状态
得到中断异常
run方法执行完毕
```
从这里可以看出，通过interrupt方法可以中断处于阻塞状态的线程。那么能不能中断处于非阻塞状态的线程呢？看下面这个例子：
```java
public class Test {
     
    public static void main(String[] args) throws IOException  {
        Test test = new Test();
        MyThread thread = test.new MyThread();
        thread.start();
        try {
            Thread.currentThread().sleep(2000);
        } catch (InterruptedException e) {
             
        }
        thread.interrupt();
    } 
     
    class MyThread extends Thread{
        @Override
        public void run() {
            int i = 0;
            while(i<Integer.MAX_VALUE){
                System.out.println(i+" while循环");
                i++;
            }
        }
    }
}
```
运行该程序会发现，while循环会一直运行直到变量i的值超出Integer.MAX_VALUE。所以说直接调用interrupt方法不能中断正在运行中的线程。

但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。比如下面这段代码：
```java
public class Test {
     
    public static void main(String[] args) throws IOException  {
        Test test = new Test();
        MyThread thread = test.new MyThread();
        thread.start();
        try {
            Thread.currentThread().sleep(2000);
        } catch (InterruptedException e) {
             
        }
        thread.interrupt();
    } 
     
    class MyThread extends Thread{
        @Override
        public void run() {
            int i = 0;
            while(!isInterrupted() && i<Integer.MAX_VALUE){
                System.out.println(i+" while循环");
                i++;
            }
        }
    }
}
```
运行会发现，打印若干个值之后，while循环就停止打印了。

但是一般情况下不建议通过这种方式来中断线程，一般会在MyThread类中增加一个属性 isStop来标志是否结束while循环，然后再在while循环中判断isStop的值。
```java
class MyThread extends Thread{
	private volatile boolean isStop = false;
	@Override
	public void run() {
		int i = 0;
		while(!isStop){
			i++;
		}
	}
	 
	public void setStop(boolean stop){
		this.isStop = stop;
	}
}
```
那么就可以在外面通过调用setStop方法来终止while循环。

7）stop方法
stop方法已经是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。

8）destroy方法
destroy方法也是废弃的方法。基本不会被使用到。

9）currentThread方法
这是个静态方法、native方法。源码如下
```java
/**
 * Returns a reference to the currently executing thread object.
 *
 * @return  the currently executing thread.
 */
public static native Thread currentThread();
```
这个方法比较常用，`Thread.currentThread().getName()`

# 属性
以下是线程中的几个重要的属性，可以通过getter/setter/is×××获得
1）id
线程ID。线程的ID不允许被修改，所以没有setId()方法

2）name
线程名称。如果没有为线程指定一个名字，JVM将自动给它分配一个名字，格式是Thread-××，其中××是一组数字。

3）priority
线程优先级。从1到10.，其中1是最低优先级；10是最高优先级。一般不推荐去改变线程的优先级，然而，在需要的时候，也可以这儿做。Thread类定义了三个优先级常量
```java
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
```

4）daemon
用来设置线程是否成为守护线程和判断线程是否是守护线程。
 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。
如果某一个线程调用了System.exit()指定来结束程序的执行，所有的线程都将结束。

5）status
线程的状态，在java中，线程的状态有6种：new、runnable、blocked、waiting、time waiting、terminated。Thread.Status是一个enum类型，保存了这六种状态。
线程的status不允许被修改，所以没有setStatus()方法

# 线程中不可控异常的处理
我们看到run方法不能throws异常，如果报出一个运行时异常那咋搞？好在，Java提供给我们一种在线程对象里捕获和处理运行时异常的一种机制。
```java
thread.setUncaughtExceptionHandler(new     
    Thread.UncaughtExceptionHandler() {
			
	@Override
	public void uncaughtException(Thread t, Throwable e) {
		System.out.println("报错了...");
		
	}
})
```
随便写个代码，抛一个运行时异常就行了，就能验证这个功能。
Thread类还有另一个方法可以处理未捕获到的异常，即静态方法`setDefaultUncaughtExceptionHandler()`。这个方法在应用程序中为所有的线程对象创建了一个异常处理器。

当线程抛出一个未捕获的异常并且没有被捕获时** (这种情况只可能是运行时异常) **，JVM将为异常寻找以下三种可能的处理器：
首先，它查找线程对象的未捕获异常处理器。如果找不到，JVM继续查找线程对象所在的线程组（ThreadGroup）的未捕获异常处理器。如果还是找不到（参考文章《线程组》），如同本节所讲的，JVM将继续查找默认的未捕获异常处理器。
如果没有一个处理器存在，JVM则将堆栈异常记录打印到控制台，并退出程序。


