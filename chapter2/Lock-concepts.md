在大家看一些资料和文章时，可能会提及一些xxx锁，这里简单总结一下锁的有关特性和锁分类

# 可重入性
当某线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。如果某个线程试图获得一个已经由它自己持有的锁时，那么这个请求就会成功，而不会出现把自己锁死的问题，这就是可重入性。
如果锁具备可重入性，则称作为可重入锁，synchronized和ReentrantLock都是可重入锁。

# 偏向锁
Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。

偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。

向锁只能在单线程下起作用，如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁

可重入性偏向锁最基本的条件，而偏向锁则是对单线程的优化。

可以在JVM中使用-XX:+UseBiasedLocking=false关闭偏向锁，默认是true。

偏向锁与轻量级锁设计的区别：
轻量级锁：在无竞争的情况下使用CAS操作去消除同步使用的互斥量
偏向锁：在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了


# 可中断锁
一个线程可以响应中断，则称为可中断锁。
如果某一线程正在等待获取锁，可能由于等待时间很长，该线程不想等待了，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
在Java中，synchronized就不是可中断锁，而Lock是可中断锁。Lock提供的tryLock方法可以设定等待锁的超时时间，如果指定时间内获取不到锁可以中断自己，同时Lock还提供了lockInterruptibly()也可以响应中断。

#公平锁(fair lock)
等待锁时间最大的线程优先执行，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。Lock提供了设置锁的公平性参数

# 非公平锁(nonfair lock)
与公平锁想法，选择的等待锁线程是随机的，可能某个线程永远都获取不到锁

排它锁(exclusion lock)


# 自旋锁
自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。
基于自旋锁原理，等待的时候，并不释放cpu时间片，相比synchronized  wait()操作，减小了释放，重新获取的消耗。 所以自旋锁适用于并发冲突不大，且锁被占用很快就能释放的场景
自旋锁本身是JVM对锁的一种优化技术，
在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。
在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。

# 读写锁
jvm提供的锁优化机制。参考`ReadWriteLock`



参考
<http://www.cnblogs.com/softidea/p/5530761.html>
<http://blog.csdn.net/liushengbaoblog/article/details/39227863>

